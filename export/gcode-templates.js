/**
 * @file        export/gcode-templates.js
 * @description Post-processor templates for various CNC controllers
 * @author      Eltryus - Ricardo Marques
 * @license     AGPL-3.0-or-later
 */

/*
 * EasyTrace5000 - Advanced PCB Isolation CAM Workspace
 * Copyright (C) 2025 Eltryus
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

(function() {
    'use strict';
    
    const config = window.PCBCAMConfig || {};
    const gcodeConfig = config.gcode || {};
    
    /**
     * Base post-processor class
     */
    class PostProcessor {
        constructor(name, config) {
            this.name = name;
            this.config = {
                fileExtension: '.nc',
                supportsToolChange: false,
                supportsArcCommands: true,
                supportsCannedCycles: false,
                arcFormat: 'IJ', // IJ or R
                coordinatePrecision: 3,
                feedPrecision: 0,
                spindlePrecision: 0,
                lineNumbering: false,
                blockDelete: false,
                modalGroups: true,
                ...config
            };
            
            this.lineNumber = 10;
            this.lineIncrement = 10;
            this.modalState = {};
        }
        
        /**
         * Generate file header
         */
        generateHeader(options) {
            const lines = [];
            
            // Comments
            lines.push(`(${'-'.repeat(40)})`);
            lines.push(`(Generated by EasyTrace5000)`);
            lines.push(`(Date: ${new Date().toISOString()})`);
            lines.push(`(Post: ${this.name})`);
            if (options.fileName) {
                lines.push(`(File: ${options.fileName})`);
            }
            lines.push(`(${'-'.repeat(40)})`);
            lines.push('');
            
            return lines;
        }
        
        /**
         * Generate file footer
         */
        generateFooter(options) {
            const lines = [];
            
            lines.push('');
            lines.push(`(${'-'.repeat(40)})`);
            lines.push('(End of program)');
            lines.push(`(${'-'.repeat(40)})`);
            
            return lines;
        }
        
        /**
         * Generate tool change sequence
         */
        generateToolChange(tool, options) {
            const lines = [];
            
            if (!this.config.supportsToolChange) {
                // Manual tool change
                lines.push('');
                lines.push(`(${'-'.repeat(30)})`);
                lines.push(`(Tool change: ${tool.id || 'T' + tool.number})`);
                lines.push(`(Diameter: ${tool.diameter}mm)`);
                lines.push(`(${'-'.repeat(30)})`);
                lines.push('M5 (Stop spindle)');
                lines.push(`G0 Z${this.formatCoordinate(options.safeZ || 25)}`);
                lines.push('M0 (Pause for tool change)');
            }
            
            return lines;
        }
        
        /**
         * Format coordinate value
         */
        formatCoordinate(value) {
            if (value === null || value === undefined) return '';
            return value.toFixed(this.config.coordinatePrecision).replace(/\.?0+$/, '');
        }
        
        /**
         * Format feed rate
         */
        formatFeed(value) {
            if (this.config.feedPrecision === 0) {
                return Math.round(value).toString();
            }
            return value.toFixed(this.config.feedPrecision).replace(/\.?0+$/, '');
        }
        
        /**
         * Format spindle speed
         */
        formatSpindle(value) {
            if (this.config.spindlePrecision === 0) {
                return Math.round(value).toString();
            }
            return value.toFixed(this.config.spindlePrecision).replace(/\.?0+$/, '');
        }
        
        /**
         * Add line number if enabled
         */
        addLineNumber(line) {
            if (!this.config.lineNumbering) return line;
            
            const numbered = `N${this.lineNumber} ${line}`;
            this.lineNumber += this.lineIncrement;
            return numbered;
        }
        
        /**
         * Process template string with variables
         */
        processTemplate(template, variables) {
            let processed = template;
            
            for (const [key, value] of Object.entries(variables)) {
                const regex = new RegExp(`\\{${key}\\}`, 'g');
                let formattedValue = value;
                
                // Format based on variable name
                if (key.includes('Z') || key.includes('X') || key.includes('Y')) {
                    formattedValue = this.formatCoordinate(value);
                } else if (key.includes('feed') || key.includes('Feed')) {
                    formattedValue = this.formatFeed(value);
                } else if (key.includes('spindle') || key.includes('Speed')) {
                    formattedValue = this.formatSpindle(value);
                }
                
                processed = processed.replace(regex, formattedValue);
            }
            
            return processed;
        }
    }
    
    /**
     * GRBL post-processor
     */
    class GRBLPostProcessor extends PostProcessor {
        constructor() {
            super('GRBL', {
                fileExtension: '.nc',
                supportsToolChange: false,
                supportsArcCommands: true,
                supportsCannedCycles: false,
                arcFormat: 'IJ',
                coordinatePrecision: 3,
                feedPrecision: 0,
                spindlePrecision: 0,
                modalGroups: true,
                maxSpindleSpeed: 30000,
                rapidFeedRate: 1000
            });
        }
        
        generateHeader(options) {
            const lines = super.generateHeader(options);
            
            // GRBL initialization
            lines.push('G90 (Absolute positioning)');
            lines.push('G21 (Metric units)');
            lines.push('G17 (XY plane)');
            lines.push('G94 (Units per minute feed)');
            lines.push('G54 (Work coordinate system)');
            lines.push('');
            
            // Spindle start
            const spindleSpeed = options.spindleSpeed || 12000;
            lines.push(`M3 S${this.formatSpindle(spindleSpeed)} (Start spindle)`);
            lines.push('G4 P1 (Dwell 1 second)');
            lines.push('');
            
            // Initial position
            lines.push(`G0 Z${this.formatCoordinate(options.safeZ || 5)}`);
            lines.push('G0 X0 Y0');
            lines.push('');
            
            return lines;
        }
        
        generateFooter(options) {
            const lines = [];
            
            // Retract and stop
            lines.push('');
            lines.push('M5 (Stop spindle)');
            lines.push(`G0 Z${this.formatCoordinate(options.safeZ || 5)}`);
            lines.push('G0 X0 Y0 (Return to origin)');
            lines.push('M2 (Program end)');
            
            // Add base footer
            lines.push(...super.generateFooter(options));
            
            return lines;
        }
        
        generateToolChange(tool, options) {
            const lines = super.generateToolChange(tool, options);
            
            // Resume after tool change
            lines.push('');
            lines.push(`M3 S${this.formatSpindle(tool.spindleSpeed || 12000)}`);
            lines.push('G4 P1 (Wait for spindle)');
            lines.push(`G0 Z${this.formatCoordinate(options.travelZ || 2)}`);
            lines.push('');
            
            return lines;
        }
        
        /**
         * Format motion command for GRBL
         */
        formatMotionCommand(cmd, state) {
            let gcode = '';
            
            switch(cmd.type) {
                case 'RAPID':
                    // Only output G0 if not in rapid mode
                    if (state.motionMode !== 'G0') {
                        gcode = 'G0';
                        state.motionMode = 'G0';
                    }
                    break;
                    
                case 'LINEAR':
                    if (state.motionMode !== 'G1') {
                        gcode = 'G1';
                        state.motionMode = 'G1';
                    }
                    break;
                    
                case 'ARC_CW':
                    if (state.motionMode !== 'G2') {
                        gcode = 'G2';
                        state.motionMode = 'G2';
                    }
                    break;
                    
                case 'ARC_CCW':
                    if (state.motionMode !== 'G3') {
                        gcode = 'G3';
                        state.motionMode = 'G3';
                    }
                    break;
                    
                case 'PLUNGE':
                    if (state.motionMode !== 'G1') {
                        gcode = 'G1';
                        state.motionMode = 'G1';
                    }
                    break;
                    
                case 'RETRACT':
                    if (state.motionMode !== 'G0') {
                        gcode = 'G0';
                        state.motionMode = 'G0';
                    }
                    break;
                    
                case 'DWELL':
                    return `G4 P${cmd.duration || 0}`;
            }
            
            // Add coordinates
            if (cmd.x !== null && cmd.x !== undefined) {
                gcode += ` X${this.formatCoordinate(cmd.x)}`;
            }
            if (cmd.y !== null && cmd.y !== undefined) {
                gcode += ` Y${this.formatCoordinate(cmd.y)}`;
            }
            if (cmd.z !== null && cmd.z !== undefined) {
                gcode += ` Z${this.formatCoordinate(cmd.z)}`;
            }
            
            // Add arc parameters
            if (cmd.type === 'ARC_CW' || cmd.type === 'ARC_CCW') {
                if (cmd.i !== undefined) {
                    gcode += ` I${this.formatCoordinate(cmd.i)}`;
                }
                if (cmd.j !== undefined) {
                    gcode += ` J${this.formatCoordinate(cmd.j)}`;
                }
            }
            
            // Add feed rate if changed
            if (cmd.feed !== undefined && cmd.feed !== state.currentFeed) {
                gcode += ` F${this.formatFeed(cmd.feed)}`;
                state.currentFeed = cmd.feed;
            }
            
            return gcode.trim();
        }
        
        /**
         * Validate GRBL compatibility
         */
        validateGCode(lines) {
            const warnings = [];
            const errors = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Check for unsupported canned cycles
                if (/G8[0-9]/.test(line)) {
                    errors.push(`Line ${i + 1}: Canned cycles not supported by GRBL`);
                }
                
                // Check for tool changes
                if (/M6|T\d+/.test(line)) {
                    warnings.push(`Line ${i + 1}: Automatic tool changes not supported`);
                }
                
                // Check spindle speed range
                const spindleMatch = line.match(/S(\d+)/);
                if (spindleMatch) {
                    const speed = parseInt(spindleMatch[1]);
                    if (speed > this.config.maxSpindleSpeed) {
                        warnings.push(`Line ${i + 1}: Spindle speed ${speed} exceeds maximum`);
                    }
                }
            }
            
            return { warnings, errors, valid: errors.length === 0 };
        }
    }
    
    /**
     * Template factory
     */
    class GCodeTemplates {
        constructor() {
            this.processors = new Map();
            
            // Register default processors
            this.registerProcessor('grbl', new GRBLPostProcessor());
            
            // Base template for adding more processors
            this.baseProcessorConfig = {
                marlin: {
                    fileExtension: '.gcode',
                    supportsToolChange: false,
                    supportsArcCommands: true,
                    supportsCannedCycles: false,
                    arcFormat: 'IJ',
                    coordinatePrecision: 3,
                    feedPrecision: 0,
                    spindlePrecision: 0
                },
                linuxcnc: {
                    fileExtension: '.ngc',
                    supportsToolChange: true,
                    supportsArcCommands: true,
                    supportsCannedCycles: true,
                    arcFormat: 'IJ',
                    coordinatePrecision: 4,
                    feedPrecision: 1,
                    spindlePrecision: 0
                },
                mach3: {
                    fileExtension: '.tap',
                    supportsToolChange: true,
                    supportsArcCommands: true,
                    supportsCannedCycles: true,
                    arcFormat: 'IJ',
                    coordinatePrecision: 4,
                    feedPrecision: 1,
                    spindlePrecision: 0
                }
            };
        }
        
        /**
         * Register a post-processor
         */
        registerProcessor(name, processor) {
            this.processors.set(name.toLowerCase(), processor);
        }
        
        /**
         * Get a post-processor
         */
        getProcessor(name) {
            return this.processors.get(name.toLowerCase()) || this.processors.get('grbl');
        }
        
        /**
         * List available processors
         */
        listProcessors() {
            return Array.from(this.processors.keys());
        }
        
        /**
         * Create a custom processor from config
         */
        createCustomProcessor(name, config) {
            const processor = new PostProcessor(name, config);
            this.registerProcessor(name, processor);
            return processor;
        }
    }
    
    // Export
    window.PostProcessor = PostProcessor;
    window.GRBLPostProcessor = GRBLPostProcessor;
    window.GCodeTemplates = GCodeTemplates;
    
})();